package debug

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"firesalamander/internal/config"
	"firesalamander/internal/constants"
	"firesalamander/internal/logger"
)

type PhaseTest struct {
	Phase       string                         `json:"phase"`
	Name        string                         `json:"name"`
	Description string                         `json:"description"`
	Status      string                         `json:"status"`
	Message     string                         `json:"message"`
	Duration    string                         `json:"duration"`
	Details     map[string]interface{}         `json:"details,omitempty"`
	SubTests    []PhaseTest                    `json:"sub_tests,omitempty"`
	Error       string                         `json:"error,omitempty"`
}

type PhaseTestSuite struct {
	Phase       string      `json:"phase"`
	Status      string      `json:"status"`
	TotalTests  int         `json:"total_tests"`
	PassedTests int         `json:"passed_tests"`
	FailedTests int         `json:"failed_tests"`
	Duration    string      `json:"duration"`
	Tests       []PhaseTest `json:"tests"`
}

var testLog = logger.New("PHASE-TESTS")

func RunPhase1Tests(cfg *config.Config) *PhaseTestSuite {
	testLog.Info("ðŸ§ª Running Phase 1 Tests - Setup Initial")
	
	start := time.Now()
	suite := &PhaseTestSuite{
		Phase:  constants.Phase1SetupInitial,
		Status: constants.StatusRunning,
		Tests:  []PhaseTest{},
	}
	
	// Test 1: Configuration
	suite.Tests = append(suite.Tests, runConfigTest(cfg))
	
	// Test 2: File Structure
	suite.Tests = append(suite.Tests, runFileStructureTest())
	
	// Test 3: Git Setup
	suite.Tests = append(suite.Tests, runGitTest())
	
	// Test 4: HTTP Server
	suite.Tests = append(suite.Tests, runServerTest(cfg))
	
	// Test 5: Branding
	suite.Tests = append(suite.Tests, runBrandingTest())
	
	// Test 6: Docker Setup
	suite.Tests = append(suite.Tests, runDockerTest())
	
	// Test 7: Deploy Scripts
	suite.Tests = append(suite.Tests, runDeployScriptsTest())
	
	// Calculer les rÃ©sultats
	suite.TotalTests = len(suite.Tests)
	for _, test := range suite.Tests {
		if test.Status == constants.StatusPassed {
			suite.PassedTests++
		} else {
			suite.FailedTests++
		}
	}
	
	if suite.FailedTests == 0 {
		suite.Status = constants.StatusPassed
	} else {
		suite.Status = constants.StatusFailed
	}
	
	suite.Duration = time.Since(start).String()
	
	testLog.Info("ðŸ§ª Phase 1 Tests completed", map[string]interface{}{
		"status":        suite.Status,
		"total_tests":   suite.TotalTests,
		"passed_tests":  suite.PassedTests,
		"failed_tests":  suite.FailedTests,
		"duration":      suite.Duration,
	})
	
	return suite
}

func runConfigTest(cfg *config.Config) PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestConfigurationLoading,
		Description: constants.DescConfigurationLoading,
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running configuration test")
	
	if cfg == nil {
		test.Status = constants.StatusFailed
		test.Message = constants.ErrConfigurationNil
		test.Error = "config_nil"
		test.Duration = time.Since(start).String()
		return test
	}
	
	issues := []string{}
	
	// Test App config (using constants)
	appName := constants.AppName
	if appName == "" || appName != "Fire Salamander" {
		issues = append(issues, "app.name incorrect")
	}
	
	// Test Server  
	if cfg.Port <= 0 {
		issues = append(issues, "server.port invalid")
	}
	
	test.Details["app_name"] = constants.AppName
	test.Details["app_icon"] = constants.AppIcon
	test.Details["powered_by"] = constants.PoweredBy  
	test.Details["primary_color"] = constants.PrimaryColor
	test.Details["server_port"] = cfg.Port
	test.Details["issues_found"] = len(issues)
	
	if len(issues) > 0 {
		test.Status = constants.StatusFailed
		test.Message = fmt.Sprintf("Configuration validation failed: %s", strings.Join(issues, ", "))
		test.Details["issues"] = issues
	} else {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgConfigurationValid
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runFileStructureTest() PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestFileStructure,
		Description: "Verify all required files and directories exist",
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running file structure test")
	
	requiredFiles := []string{
		"go.mod",
		"main.go",
		"README.md",
		".gitignore",
		"docker-compose.yml",
	}
	
	requiredDirs := []string{
		"config",
		"deploy",
		"internal",
		"internal/logger",
		"internal/debug",
	}
	
	missingFiles := []string{}
	missingDirs := []string{}
	
	// Check files
	for _, file := range requiredFiles {
		if _, err := os.Stat(file); os.IsNotExist(err) {
			missingFiles = append(missingFiles, file)
		}
	}
	
	// Check directories
	for _, dir := range requiredDirs {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			missingDirs = append(missingDirs, dir)
		}
	}
	
	test.Details["required_files"] = len(requiredFiles)
	test.Details["required_dirs"] = len(requiredDirs)
	test.Details["missing_files"] = len(missingFiles)
	test.Details["missing_dirs"] = len(missingDirs)
	
	if len(missingFiles) > 0 || len(missingDirs) > 0 {
		test.Status = constants.StatusFailed
		test.Message = fmt.Sprintf("Missing %d files and %d directories", len(missingFiles), len(missingDirs))
		if len(missingFiles) > 0 {
			test.Details["missing_files_list"] = missingFiles
		}
		if len(missingDirs) > 0 {
			test.Details["missing_dirs_list"] = missingDirs
		}
	} else {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgAllFilesExist
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runGitTest() PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        "Git Setup",
		Description: "Verify Git repository is initialized with remote",
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running Git setup test")
	
	issues := []string{}
	
	// Check .git directory
	if _, err := os.Stat(".git"); os.IsNotExist(err) {
		issues = append(issues, ".git directory missing")
	} else {
		test.Details["git_initialized"] = true
	}
	
	// Check .gitignore
	if _, err := os.Stat(".gitignore"); os.IsNotExist(err) {
		issues = append(issues, ".gitignore missing")
	} else {
		test.Details["gitignore_exists"] = true
	}
	
	test.Details["issues_found"] = len(issues)
	
	if len(issues) > 0 {
		test.Status = constants.StatusFailed
		test.Message = fmt.Sprintf("Git setup issues: %s", strings.Join(issues, ", "))
		test.Details["issues"] = issues
	} else {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgGitProperlyInitialized
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runServerTest(cfg *config.Config) PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestHTTPServer,
		Description: constants.DescHTTPServer,
		Details:     make(map[string]interface{}),
		SubTests:    []PhaseTest{},
	}
	
	testLog.Debug("Running HTTP server test")
	
	if cfg == nil {
		test.Status = constants.StatusFailed
		test.Message = "Cannot test server - configuration is nil"
		test.Duration = time.Since(start).String()
		return test
	}
	
	baseURL := fmt.Sprintf(constants.HTTPPrefix+"localhost:%d", cfg.Port)
	test.Details["base_url"] = baseURL
	
	// Test health endpoint
	healthTest := testEndpoint("Health Endpoint", baseURL+"/health", "application/json")
	test.SubTests = append(test.SubTests, healthTest)
	
	// Test debug endpoint
	debugTest := testEndpoint("Debug Endpoint", baseURL+"/debug", "application/json")
	test.SubTests = append(test.SubTests, debugTest)
	
	// Test home page
	homeTest := testEndpoint("Home Page", baseURL+"/", "text/html")
	test.SubTests = append(test.SubTests, homeTest)
	
	// Calculate overall status
	passedTests := 0
	for _, subTest := range test.SubTests {
		if subTest.Status == constants.StatusPassed {
			passedTests++
		}
	}
	
	test.Details["total_endpoints"] = len(test.SubTests)
	test.Details["passed_endpoints"] = passedTests
	
	if passedTests == len(test.SubTests) {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgAllEndpointsResponding
	} else {
		test.Status = constants.StatusFailed
		test.Message = fmt.Sprintf("Only %d/%d endpoints responding correctly", passedTests, len(test.SubTests))
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func testEndpoint(name, url, expectedContentType string) PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Name:        name,
		Description: fmt.Sprintf("Test %s is accessible", url),
		Details:     make(map[string]interface{}),
	}
	
	test.Details["url"] = url
	test.Details["expected_content_type"] = expectedContentType
	
	client := &http.Client{Timeout: constants.FastRequestTimeout}
	resp, err := client.Get(url)
	if err != nil {
		test.Status = constants.StatusFailed
		test.Message = "Endpoint not accessible"
		test.Error = err.Error()
		test.Details["accessible"] = false
	} else {
		defer resp.Body.Close()
		
		test.Details["accessible"] = true
		test.Details["status_code"] = resp.StatusCode
		test.Details["content_type"] = resp.Header.Get("Content-Type")
		
		if resp.StatusCode == 200 {
			contentType := resp.Header.Get("Content-Type")
			if strings.Contains(contentType, expectedContentType) {
				test.Status = constants.StatusPassed
				test.Message = constants.MsgEndpointRespondingCorrect
			} else {
				test.Status = constants.StatusFailed
				test.Message = fmt.Sprintf("Wrong content type: got %s, expected %s", contentType, expectedContentType)
			}
		} else {
			test.Status = constants.StatusFailed
			test.Message = fmt.Sprintf("Unexpected status code: %d", resp.StatusCode)
		}
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runBrandingTest() PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestSEPTEOBranding,
		Description: "Verify SEPTEO branding elements are properly integrated",
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running branding test")
	
	issues := []string{}
	
	// Check main.go for SEPTEO logo URL
	if content, err := os.ReadFile("main.go"); err == nil {
		contentStr := string(content)
		if !strings.Contains(contentStr, "septeo.svg") {
			issues = append(issues, "SEPTEO logo URL not found in main.go")
		} else {
			test.Details["septeo_logo_integrated"] = true
		}
		
		if !strings.Contains(contentStr, "#ff6136") {
			issues = append(issues, "SEPTEO orange color not found")
		} else {
			test.Details["septeo_orange_integrated"] = true
		}
		
		if !strings.Contains(contentStr, "ðŸ¦Ž") {
			issues = append(issues, "Fire Salamander icon not found")
		} else {
			test.Details["salamander_icon_integrated"] = true
		}
	} else {
		issues = append(issues, "Cannot read main.go file")
	}
	
	test.Details["issues_found"] = len(issues)
	
	if len(issues) > 0 {
		test.Status = constants.StatusFailed
		test.Message = fmt.Sprintf("Branding issues: %s", strings.Join(issues, ", "))
		test.Details["issues"] = issues
	} else {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgSEPTEOBrandingIntegrated
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runDockerTest() PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestDockerSetup,
		Description: constants.DescDockerSetup,
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running Docker setup test")
	
	if _, err := os.Stat("docker-compose.yml"); os.IsNotExist(err) {
		test.Status = constants.StatusFailed
		test.Message = "docker-compose.yml file missing"
		test.Error = "docker_compose_missing"
	} else {
		// Check if docker-compose.yml contains required services
		if content, err := os.ReadFile("docker-compose.yml"); err == nil {
			contentStr := string(content)
			
			hasAppService := strings.Contains(contentStr, "app:")
			hasDbService := strings.Contains(contentStr, "db:")
			hasPortMapping := strings.Contains(contentStr, constants.TestPort3000+":"+constants.TestPort3000)
			
			test.Details["has_app_service"] = hasAppService
			test.Details["has_db_service"] = hasDbService
			test.Details["has_port_mapping"] = hasPortMapping
			
			if hasAppService && hasDbService && hasPortMapping {
				test.Status = constants.StatusPassed
				test.Message = constants.MsgDockerComposeValid
			} else {
				test.Status = constants.StatusFailed
				test.Message = "Docker Compose configuration is incomplete"
			}
		} else {
			test.Status = constants.StatusFailed
			test.Message = "Cannot read docker-compose.yml"
			test.Error = err.Error()
		}
	}
	
	test.Duration = time.Since(start).String()
	return test
}

func runDeployScriptsTest() PhaseTest {
	start := time.Now()
	test := PhaseTest{
		Phase:       "1",
		Name:        constants.TestDeployScripts,
		Description: constants.DescDeployScripts,
		Details:     make(map[string]interface{}),
	}
	
	testLog.Debug("Running deploy scripts test")
	
	scripts := []string{
		"deploy/deploy.sh",
		"deploy/setup-infomaniak.sh",
	}
	
	missingScripts := []string{}
	nonExecutableScripts := []string{}
	
	for _, script := range scripts {
		if stat, err := os.Stat(script); os.IsNotExist(err) {
			missingScripts = append(missingScripts, script)
		} else {
			// Check if executable
			mode := stat.Mode()
			if mode&0111 == 0 { // Check if any execute bit is set
				nonExecutableScripts = append(nonExecutableScripts, script)
			}
		}
	}
	
	test.Details["total_scripts"] = len(scripts)
	test.Details["missing_scripts"] = len(missingScripts)
	test.Details["non_executable_scripts"] = len(nonExecutableScripts)
	
	if len(missingScripts) > 0 || len(nonExecutableScripts) > 0 {
		test.Status = constants.StatusFailed
		issues := []string{}
		if len(missingScripts) > 0 {
			issues = append(issues, fmt.Sprintf("%d missing scripts", len(missingScripts)))
			test.Details["missing_scripts_list"] = missingScripts
		}
		if len(nonExecutableScripts) > 0 {
			issues = append(issues, fmt.Sprintf("%d non-executable scripts", len(nonExecutableScripts)))
			test.Details["non_executable_scripts_list"] = nonExecutableScripts
		}
		test.Message = fmt.Sprintf("Deploy script issues: %s", strings.Join(issues, ", "))
	} else {
		test.Status = constants.StatusPassed
		test.Message = constants.MsgAllDeployScriptsReady
	}
	
	test.Duration = time.Since(start).String()
	return test
}