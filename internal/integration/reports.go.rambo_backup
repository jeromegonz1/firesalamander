package integration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html/template"
	"strings"
	"time"
)

// ReportGenerator générateur de rapports Fire Salamander
type ReportGenerator struct {
	templates map[string]*template.Template
}

// ReportFormat format de rapport
type ReportFormat string

const (
	ReportFormatHTML ReportFormat = "html"
	ReportFormatJSON ReportFormat = "json"
	ReportFormatPDF  ReportFormat = "pdf"
	ReportFormatCSV  ReportFormat = "csv"
)

// ReportType type de rapport
type ReportType string

const (
	ReportTypeExecutive ReportType = "executive" // Rapport exécutif
	ReportTypeDetailed  ReportType = "detailed"  // Rapport détaillé
	ReportTypeTechnical ReportType = "technical" // Rapport technique
	ReportTypeComparison ReportType = "comparison" // Rapport de comparaison
)

// ReportOptions options de génération de rapport
type ReportOptions struct {
	Format          ReportFormat `json:"format"`
	Type            ReportType   `json:"type"`
	IncludeSummary  bool         `json:"include_summary"`
	IncludeDetails  bool         `json:"include_details"`
	IncludeCharts   bool         `json:"include_charts"`
	IncludeRawData  bool         `json:"include_raw_data"`
	CustomSections  []string     `json:"custom_sections"`
	BrandingOptions BrandingOptions `json:"branding"`
}

// BrandingOptions options de branding
type BrandingOptions struct {
	CompanyName string `json:"company_name"`
	Logo        string `json:"logo"`
	Colors      struct {
		Primary   string `json:"primary"`
		Secondary string `json:"secondary"`
	} `json:"colors"`
}

// Report rapport généré
type Report struct {
	ID          string                 `json:"id"`
	Title       string                 `json:"title"`
	Type        ReportType             `json:"type"`
	Format      ReportFormat           `json:"format"`
	GeneratedAt time.Time              `json:"generated_at"`
	Content     string                 `json:"content"`
	Metadata    map[string]interface{} `json:"metadata"`
	Size        int                    `json:"size"`
}

// ReportSummary résumé de rapport
type ReportSummary struct {
	URL               string                 `json:"url"`
	Domain            string                 `json:"domain"`
	AnalyzedAt        time.Time              `json:"analyzed_at"`
	OverallScore      float64                `json:"overall_score"`
	Grade             string                 `json:"grade"`
	TopIssues         []string               `json:"top_issues"`
	TopRecommendations []string              `json:"top_recommendations"`
	KeyMetrics        map[string]interface{} `json:"key_metrics"`
	Status            string                 `json:"status"`
}

// NewReportGenerator crée un nouveau générateur de rapports
func NewReportGenerator() *ReportGenerator {
	generator := &ReportGenerator{
		templates: make(map[string]*template.Template),
	}

	// Initialiser les templates
	generator.initTemplates()

	return generator
}

// GenerateReport génère un rapport à partir d'un résultat d'analyse
func (rg *ReportGenerator) GenerateReport(result *UnifiedAnalysisResult, options ReportOptions) (*Report, error) {
	reportID := fmt.Sprintf("report_%d", time.Now().UnixNano())

	report := &Report{
		ID:          reportID,
		Type:        options.Type,
		Format:      options.Format,
		GeneratedAt: time.Now(),
		Metadata:    make(map[string]interface{}),
	}

	// Générer le titre
	report.Title = rg.generateTitle(result, options.Type)

	// Générer le contenu selon le format
	var content string
	var err error

	switch options.Format {
	case ReportFormatHTML:
		content, err = rg.generateHTMLReport(result, options)
	case ReportFormatJSON:
		content, err = rg.generateJSONReport(result, options)
	case ReportFormatCSV:
		content, err = rg.generateCSVReport(result, options)
	default:
		return nil, fmt.Errorf("format de rapport non supporté: %s", options.Format)
	}

	if err != nil {
		return nil, fmt.Errorf("erreur génération contenu: %w", err)
	}

	report.Content = content
	report.Size = len(content)

	// Métadonnées
	report.Metadata["url"] = result.URL
	report.Metadata["domain"] = result.Domain
	report.Metadata["overall_score"] = result.OverallScore
	report.Metadata["analysis_date"] = result.AnalyzedAt
	report.Metadata["processing_time"] = result.ProcessingTime

	return report, nil
}

// generateHTMLReport génère un rapport HTML
func (rg *ReportGenerator) generateHTMLReport(result *UnifiedAnalysisResult, options ReportOptions) (string, error) {
	// Sélectionner le template approprié
	templateName := string(options.Type) + "_html"
	tmpl, exists := rg.templates[templateName]
	if !exists {
		tmpl = rg.templates["default_html"]
	}

	// Préparer les données pour le template
	data := rg.prepareTemplateData(result, options)

	// Exécuter le template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("erreur exécution template: %w", err)
	}

	return buf.String(), nil
}

// generateJSONReport génère un rapport JSON
func (rg *ReportGenerator) generateJSONReport(result *UnifiedAnalysisResult, options ReportOptions) (string, error) {
	// Créer une structure adaptée au JSON
	reportData := map[string]interface{}{
		"summary":           rg.createReportSummary(result),
		"unified_analysis":  result,
		"generated_at":      time.Now(),
		"report_options":    options,
	}

	// Filtrer selon les options
	if !options.IncludeRawData {
		// Supprimer les données brutes voluminieuses
		if unified, ok := reportData["unified_analysis"].(*UnifiedAnalysisResult); ok {
			unified.CrawlerResult = nil
		}
	}

	// Encoder en JSON avec indentation
	jsonBytes, err := json.MarshalIndent(reportData, "", "  ")
	if err != nil {
		return "", fmt.Errorf("erreur encodage JSON: %w", err)
	}

	return string(jsonBytes), nil
}

// generateCSVReport génère un rapport CSV
func (rg *ReportGenerator) generateCSVReport(result *UnifiedAnalysisResult, options ReportOptions) (string, error) {
	var csv strings.Builder

	// En-têtes CSV
	csv.WriteString("Metric,Value,Category,Status\n")

	// Métriques principales
	csv.WriteString(fmt.Sprintf("Overall Score,%.1f,Global,\n", result.OverallScore))
	csv.WriteString(fmt.Sprintf("Content Quality,%.1f,Content,\n", result.UnifiedMetrics.ContentQualityScore))
	csv.WriteString(fmt.Sprintf("Technical Health,%.1f,Technical,\n", result.UnifiedMetrics.TechnicalHealthScore))
	csv.WriteString(fmt.Sprintf("SEO Readiness,%.1f,SEO,\n", result.UnifiedMetrics.SEOReadinessScore))
	csv.WriteString(fmt.Sprintf("Performance,%.1f,Performance,\n", result.UnifiedMetrics.PerformanceScore))
	csv.WriteString(fmt.Sprintf("Mobile Friendliness,%.1f,Mobile,\n", result.UnifiedMetrics.MobileFriendlinessScore))

	// Scores par catégorie
	for category, score := range result.CategoryScores {
		csv.WriteString(fmt.Sprintf("%s,%.1f,Category,\n", strings.Title(category), score))
	}

	// Recommandations prioritaires
	csv.WriteString("\nRecommendation,Priority,Impact,Module,Effort\n")
	for _, action := range result.PriorityActions {
		csv.WriteString(fmt.Sprintf("\"%s\",%s,%s,%s,%s\n",
			strings.ReplaceAll(action.Title, "\"", "\"\""),
			action.Priority,
			action.Impact,
			action.Module,
			action.Effort))
	}

	return csv.String(), nil
}

// createReportSummary crée un résumé de rapport
func (rg *ReportGenerator) createReportSummary(result *UnifiedAnalysisResult) ReportSummary {
	summary := ReportSummary{
		URL:          result.URL,
		Domain:       result.Domain,
		AnalyzedAt:   result.AnalyzedAt,
		OverallScore: result.OverallScore,
		Grade:        rg.calculateGrade(result.OverallScore),
		Status:       string(result.Status),
		KeyMetrics:   make(map[string]interface{}),
	}

	// Top issues (basé sur les erreurs et insights)
	var topIssues []string
	for _, insight := range result.CrossModuleInsights {
		if insight.Severity == "warning" || insight.Severity == "error" {
			topIssues = append(topIssues, insight.Title)
		}
		if len(topIssues) >= 5 {
			break
		}
	}
	summary.TopIssues = topIssues

	// Top recommandations (5 premières actions prioritaires)
	var topRecs []string
	for i, action := range result.PriorityActions {
		if i >= 5 {
			break
		}
		topRecs = append(topRecs, action.Title)
	}
	summary.TopRecommendations = topRecs

	// Métriques clés
	summary.KeyMetrics["content_quality"] = result.UnifiedMetrics.ContentQualityScore
	summary.KeyMetrics["technical_health"] = result.UnifiedMetrics.TechnicalHealthScore
	summary.KeyMetrics["seo_readiness"] = result.UnifiedMetrics.SEOReadinessScore
	summary.KeyMetrics["performance"] = result.UnifiedMetrics.PerformanceScore
	summary.KeyMetrics["mobile_score"] = result.UnifiedMetrics.MobileFriendlinessScore

	return summary
}

// prepareTemplateData prépare les données pour les templates
func (rg *ReportGenerator) prepareTemplateData(result *UnifiedAnalysisResult, options ReportOptions) map[string]interface{} {
	data := map[string]interface{}{
		"Result":    result,
		"Options":   options,
		"Summary":   rg.createReportSummary(result),
		"Generated": time.Now().Format("2006-01-02 15:04:05"),
		"Grade":     rg.calculateGrade(result.OverallScore),
		"Branding":  options.BrandingOptions,
	}

	// Ajouter des données calculées
	data["ScoreColor"] = rg.getScoreColor(result.OverallScore)
	data["StatusIcon"] = rg.getStatusIcon(result.Status)
	data["TopCategories"] = rg.getTopCategories(result.CategoryScores)
	data["BottomCategories"] = rg.getBottomCategories(result.CategoryScores)

	return data
}

// initTemplates initialise les templates de rapport
func (rg *ReportGenerator) initTemplates() {
	// Template HTML exécutif
	executiveHTML := `
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport Fire Salamander - {{.Result.URL}}</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .header { background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; padding: 30px; border-radius: 10px 10px 0 0; }
        .header h1 { margin: 0; font-size: 2.5em; }
        .header p { margin: 10px 0 0 0; opacity: 0.9; }
        .main-score { text-align: center; padding: 40px; background: #f8f9fa; }
        .score-circle { display: inline-block; width: 150px; height: 150px; border-radius: 50%; background: {{.ScoreColor}}; color: white; line-height: 150px; font-size: 3em; font-weight: bold; margin-bottom: 20px; }
        .grade { font-size: 2em; color: #333; margin: 10px 0; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; padding: 30px; }
        .metric { background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #ff6b35; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metric h3 { margin: 0 0 10px 0; color: #333; }
        .metric .value { font-size: 2em; font-weight: bold; color: #ff6b35; }
        .recommendations { padding: 30px; }
        .recommendations h2 { color: #333; border-bottom: 2px solid #ff6b35; padding-bottom: 10px; }
        .rec-item { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #28a745; }
        .footer { text-align: center; padding: 20px; color: #666; border-top: 1px solid #eee; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔥 Fire Salamander</h1>
            <p>Rapport d'analyse SEO et sémantique</p>
            <p><strong>{{.Result.URL}}</strong> • {{.Generated}}</p>
        </div>
        
        <div class="main-score">
            <div class="score-circle">{{printf "%.0f" .Result.OverallScore}}</div>
            <div class="grade">Grade: {{.Grade}}</div>
            <p>Score global d'optimisation</p>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <h3>Qualité du Contenu</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.ContentQualityScore}}</div>
            </div>
            <div class="metric">
                <h3>Santé Technique</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.TechnicalHealthScore}}</div>
            </div>
            <div class="metric">
                <h3>Préparation SEO</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.SEOReadinessScore}}</div>
            </div>
            <div class="metric">
                <h3>Performance</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.PerformanceScore}}</div>
            </div>
            <div class="metric">
                <h3>Mobile-Friendly</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.MobileFriendlinessScore}}</div>
            </div>
            <div class="metric">
                <h3>Expérience Utilisateur</h3>
                <div class="value">{{printf "%.0f" .Result.UnifiedMetrics.UserExperienceScore}}</div>
            </div>
        </div>
        
        <div class="recommendations">
            <h2>Recommandations Prioritaires</h2>
            {{range $index, $action := .Result.PriorityActions}}
            {{if lt $index 10}}
            <div class="rec-item">
                <strong>{{$action.Title}}</strong>
                <p>{{$action.Description}}</p>
                <small>Priorité: {{$action.Priority}} | Impact: {{$action.Impact}} | Module: {{$action.Module}}</small>
            </div>
            {{end}}
            {{end}}
        </div>
        
        <div class="footer">
            <p>Rapport généré par Fire Salamander • Version {{.Options.BrandingOptions.CompanyName}}</p>
            <p>Analyse effectuée le {{.Result.AnalyzedAt.Format "2006-01-02 à 15:04:05"}} • Durée: {{.Result.ProcessingTime}}</p>
        </div>
    </div>
</body>
</html>`

	// Compiler les templates
	var err error
	rg.templates["executive_html"], err = template.New("executive_html").Parse(executiveHTML)
	if err != nil {
		panic(fmt.Sprintf("Erreur compilation template executive: %v", err))
	}

	// Template par défaut (identique à executive pour l'instant)
	rg.templates["default_html"] = rg.templates["executive_html"]
	rg.templates["detailed_html"] = rg.templates["executive_html"]
	rg.templates["technical_html"] = rg.templates["executive_html"]
}

// Fonctions utilitaires

func (rg *ReportGenerator) generateTitle(result *UnifiedAnalysisResult, reportType ReportType) string {
	switch reportType {
	case ReportTypeExecutive:
		return fmt.Sprintf("Rapport Exécutif SEO - %s", result.Domain)
	case ReportTypeDetailed:
		return fmt.Sprintf("Rapport Détaillé d'Analyse - %s", result.Domain)
	case ReportTypeTechnical:
		return fmt.Sprintf("Rapport Technique SEO - %s", result.Domain)
	default:
		return fmt.Sprintf("Rapport Fire Salamander - %s", result.Domain)
	}
}

func (rg *ReportGenerator) calculateGrade(score float64) string {
	switch {
	case score >= constants.ExcellentScore90:
		return "A+"
	case score >= constants.HighQualityScore:
		return "A"
	case score >= 70:
		return "B+"
	case score >= 60:
		return "B"
	case score >= 50:
		return "C+"
	case score >= 40:
		return "C"
	case score >= 30:
		return "D"
	default:
		return "F"
	}
}

func (rg *ReportGenerator) getScoreColor(score float64) string {
	switch {
	case score >= constants.HighQualityScore:
		return "#28a745" // Vert
	case score >= 60:
		return "#ffc107" // Jaune
	case score >= 40:
		return "#fd7e14" // Orange
	default:
		return "#dc3545" // Rouge
	}
}

func (rg *ReportGenerator) getStatusIcon(status AnalysisStatus) string {
	switch status {
	case AnalysisStatusSuccess:
		return "✅"
	case AnalysisStatusPartial:
		return "⚠️"
	case AnalysisStatusFailed:
		return "❌"
	default:
		return "❓"
	}
}

func (rg *ReportGenerator) getTopCategories(scores map[string]float64) []map[string]interface{} {
	type categoryScore struct {
		name  string
		score float64
	}

	var categories []categoryScore
	for name, score := range scores {
		categories = append(categories, categoryScore{name, score})
	}

	// Trier par score décroissant
	for i := 0; i < len(categories)-1; i++ {
		for j := i + 1; j < len(categories); j++ {
			if categories[i].score < categories[j].score {
				categories[i], categories[j] = categories[j], categories[i]
			}
		}
	}

	// Retourner les 3 premiers
	var result []map[string]interface{}
	for i := 0; i < len(categories) && i < 3; i++ {
		result = append(result, map[string]interface{}{
			"name":  categories[i].name,
			"score": categories[i].score,
		})
	}

	return result
}

func (rg *ReportGenerator) getBottomCategories(scores map[string]float64) []map[string]interface{} {
	categories := rg.getTopCategories(scores)
	
	// Inverser l'ordre pour obtenir les plus faibles
	for i, j := 0, len(categories)-1; i < j; i, j = i+1, j-1 {
		categories[i], categories[j] = categories[j], categories[i]
	}

	return categories
}